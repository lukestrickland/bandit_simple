# FMAB - FUNCTIONAL MULTI ARMED BANDITS EXPERIMENT - (AKA UNCERTAINITY EXPERIMENT)  
  
This documentation.md file contains descriptions of importance of each code file and explanation of the code that is written inside each of them.
  
In essence, all the files in the project together form a web application. This web app uses the Flask framework to handle routing, connecting with database and to implement secure page access to the admin dashboard. The sequence of pages encountered by the user will be the sequence we will discuss the below. For each html page, if a stylesheet and script file exists that are connected to the html file, then their naming is as follows. If the html page is named as `index.html` then the stylesheet is named as `indexpage.css` and the script file is named as `indexScript.js`. So we will the html, css and js files of each html page all together.  
  
This web application uses the MVC (Model View Controller) Architecture. The stylesheets and javascripts files are located within the respective folders (i.e., `css` and `js`) in the `static` directory. The `app.py` is the main controller file that contains all the routing to different kinds of views, also manages the login functionality for the admin and also connects to, communicates with and manages the database (i.e., the model). The README.md contains a brief description of each and every file within the repo for quick reference. So let's start discussing about the role and some parts of the code in each of the files.  
  
  
## app.py:  
This is one of the most important code file in the entire project. At the beginning of this script, a lot of imports are made that are used in the entire project. Since this project is based on the Flask framework, it is imported. SQLAlchemy is the ORM (Object Relational Mapper) that is imported and is used to create, connect and manage the databases. Flask login is imported to deal with secure page access for admin and also to implement the login functionality along with admin user sessions. Werkzeug is used here for password hashing before saving them in the database. Next a Flask app is initialized and the SECRET_KEY is configured. For the sake of development the variable `ENV` is set to "dev". Depending on the value of ENV, the kind of database connection used will be changed. This is done to quickly switch between development and production settings. Here, we have used the value of ENV to configure some parameters like applications' debug mode and the applications' database URI. When the ENV is set to "dev" then the postgres database served from my local computer is used as a database and during the deployment phase, the database URI in the hosting platform will be used. In heroku, when an application is deployed, there is a chance that the database is moved to different location, so instead of hardcoding the database URI for production, it is directly read from the environment variables. Heroku will make sure to update the environment variables when the databases are moved to a different locations. The database URI provided by heroku starts with the `postgres://......` but this format of the URI gives out an error when the application is hosted. So the prefix is changed to `postgresql://......` within the production configuration. After the change is made, the URI is set as the SQLALCHEMY_DATABASE_URI.  
  
The Flask app that is initialized in the previous section is now passed on to the SQLAlchemy library and is maintained using the varible `db`. Then the login manager is configured and the app is again passed to the login manager so that we can use the flask login functionality within our app. The default login view is set to the "admin_login" route. This means that when the admin is logged out or not logged in and attempts to access the admin dashboard they will be automatically redirected to the admin login page.  
  
Since we dont have a lot of models or lot of routes in our application, it is not required to separate routes, models and other code into their own files. It will only add up to the complexity. Hence, for this project models and routes are in the same script.  
  
We have two data models. One is the `Userdata` model. This model stores the id, (primary key), userId (which is basically the MTurk Worker ID or anything that is analagous to that), gender, age, training data, game data and the user answers for the questions that are displayed during the training and the actual game phase, submission code that is uniquely generated for each user.  
  
The second data model is the `Admin` which stores the id (primary key), username and password. The function `load_user` is passed with the admin_id which is the id of the entry in the Admin table. This helps in loading a certain admin user from the database to be able to access the admin dashboard.  
  
The function `admin_login` checks if the current user is authenticated and then redirects them to the admin dashboard else, it will by default takes them to the admin login page. Once the user inputs the login credentials and clicks submit, a POST request is made to the same route and the username and password are checked against the Admin database. If the username and password are correct, the user will be logged in and redirected to the admin dashboard. If the username and/or password incorrect then a relavant error message is shown and the login form is still displayed for attempting again.  
  
The function `admin_dashboard` is renders the admin dashboard which requires successful admin login. Then some of the stats are calculated from the database. These stats and some of the user data is passed into the admin dashboard template and are displayed in the admin dashboard. The stats that are calculated are the number of male, female and other gender participants.  
  
The function `admin_data_download` by default redirects to the admin dashboard but when a GET request is made then except for the user password (although hashed) rest all of the columns are sent to the admin dashboard for the admin to view. These column data is arranged into one array and is jsonified and returned to the admin dashboard where it is displayed in a tabular format.  
  
The function `admin_logout` is invoked when the logout button on the admin dashboard is clicked which logs out the currently logged in admin.  
  
The function `index` renders the index.html page which contains a form to collect the user data like their MTurk worker ID (or analagous ID), their age and gender information.  
  
The function `consent` redirects to the index page when any request other than the POST request is made. But when a POST request is made from the index page after filling in the form details, those request form fields are extracted and the db is queried to check for the existence of the MTurk User ID. If the user id is already present that means this user has already taken the experiment and is redirected to the duplicate.html page (which will be discussed later) and the userId is sent to the duplicate function which does the rendering of the duplicate.html. If the user id was not already present in the database, that means the user is a new user and this user will be shown the consent page.  
  
The function `training` renders the training.html page which comes after the user has agreed to the consent agreement.  
  
The function `game` renders the game.html page which can be accessed by the user after completing the training phase which was rendered by the training function.  
  
The function `thankyou` renders the thankyou.html page by default when any request other than POST is made. But when a POST request is made to the `thankyou` route, the data from the request is extracted and the user id is checked in the database to avoid any dupicate entries. If the submission is a new one, then the data is committed to the database after a unique submission code is generated. The submission code is sent back to the front end for displaying it to the user. This submission code has to be submitted in the MTurk Worker portal for completing and recording their HIT in the MTurk website and received their reward.  
  
The function `generateSubmissionCode` which takes in one parameter, i.e., the userId and the creates a 5 digit number that was not previously assigned to any othe user. This function uses recursion to make sure the code generated for a particular user id is unique. This function then appends and prepends the 5 digit code with easily identifiable strings to create a pattern in the submission code.  
  
The function `duplicate` accepts one parameter i.e., user_id and uses this to query the database. If the user id is already present in the database, then the submission code for that user id is extracted from the database and is rendered on the duplicate.html page. If the user id is not present then the user is redirected to the error.html page.  
  
The function `page_not_found` is used to render the error.html page with specific error messages for the "Page Not Found" error.  
  
The function `internal_server_error` is another error handler function that is invoked upon encountering an "Internal Server Error" and accordingly the user is notified but using the error.html file to populate relavant informative messages.  
  
The final 2 lines of code basically starts the flask application when the app.py is executed.  
  
  
## requirements.txt:  
This text file basically contains all the modules that should be downloaded and installed in the hosting environment for this application to work properly. Upon seeing the requirements.txt file heroku will automatically start installing all these packages into the environment and makes it ready for deployment.  
  
  
## runtime.txt:  
This text file is used to specify the correct version of python to be installed in the hosting environment for our application to work. Heroku will automatically read this file and install the appropriate version of python for us.  
  
  
## Procfile:  
This is heroku specific file and is used to configure the type of WSGI server that should be used for this flask application. In this app we will be using the Gunicorn and we declare this application as a web application to inform heroku.  
  
  
## setupdatabase.py:  
This python script imports the db and Admin from the app.py. When this script is run, then all the existing tables in the db are dropped and the new ones are created. A try except statement is used to execute the new Admin object creation. So just in case the Admin credentials are already created, then this part of the code in the try block won't be executed. This script need to be executed only once to create the database and should be executed before running the app.py. This script needs to be re-run if changes are made to database schema. This script also imports the generate_password_hash from wekzeug.security so that the password for the admin is saved in the hashed format rather than as plain string.  
  
  
--------------------------
  
## ALL THE TEMPLATES AND THEIR CORRESPONDING CSS AND JS FILES
  
Except for the base.html file all other html files has an associated style sheet and a js file. Here we will not cover the explanation for the stylesheets as they are self explanatory. The js files are explained in detail.  
  
## base.html:  
This html file contains the html code that is common for all the other html files and is extended by all other templates. This is the only html file that does not contain a css and js file associated with it.  

## index.html:  
As already explained at the beginning of this document that each html file also has a css and js file associated with them. So for index.html, we have the indexpage.css and indexScript.js files providing the styles and functionality respectively. This page extends the base.html and also populates the content that should go into the `content` block in the base.html. This page contains the form elements that accept the userID, age and gender. Upon successful submission of correct credentials, the user will be redirected to the `consent` page. The form in this page has an action set to the consent route in the controller and the request made to that route is a POST request. To know how the POST requests are handled in the consent route, check the consent function explanation paragraph in the app.py section.  
  
## indexScript.js:  
This javascript file creates certain global variables to store the userId, userAge, userGender and the search parameters. When the application is deployed and the link to the application is used to create a HIT on the Mturk website, the user can click the link and due to the way the HIT is created on the MTurk website, the users' MTurk ID is appended to the end of the URL which is extracted by this js file and is stored in the `search` variable. This script has a function that is run upon the window load is complete. In that window.laod function we first make a call to the `populateAgeOptions` function which takes in two parameters which represent the lower limit and upper limit of age range that should be created in the drop down list. The populateAgeOptions function will then grab the age element from the webpage and populate it with the age options. Then we check if the variables, userID, userGender and userAge are already present in the localStorage with non null values. If this condition is true, which might be the case that the user got redirected to this page from someother page in the app. If they are found, then the input fields are auto populated. Else the program execution continues by extracting the search parameter and then checking if MID is present in the search params. If present then the MID value is filled in the userID field on the webpage and that field is made disabled (readonly) for further editing. If MID is not found in the search params then the field is just kept open for manual input.  
  
  
## consent.html:  
This html file like other html files import the base.html file and populates the html code into the `content` block in the base.html file. This page displays the consent agreement which at the time of writing this document is filled with placeholder text, but will later has to be updated with relevant consent agreement. Below the consent agreement text, there is a checkbox for the user to express their interest in accepting the agreement and proceed with the rest of the experiment. 
  
## consentScript.js:  
This js file helps in validating if the user has agreed to the consent agreement or not. Without accepting the agreement, user cannot proceed to complete the experiment. Once the user ticks the checkbox and clicks the button to proceed ahead, the function `takeToGamePage` in the js script will check if the user has checked the box or not and creates a new key value pair in the sessionStorage. After the script will change the URL location to point to the training route in the controller which will render the training.html page for the user. If the user does not agree to the consent agreement and tries to proceed ahead, an warning message is shown to the user to tick the check box to proceed ahead.  
  
  
## training.html:  
Unlike other html pages, this html page is linked to two script files. One is the `commonScript.js` file and the other is the `trainingScript.js`. The common script contains the code that is common to both the training page nad the game page. The js code that is specific to each page is written in their own js files. This html template populates the html code into the content block of the base.html page. The content block in this html page first contains the html code for displaying a modal with an overlay. Then another similar style code block which is used to display question modals is present. Then the div that contains the trail counters and reward counters is present. After the above div, another last div is present which is populated by the commonScript and controlled by the trainingScript.  
  
## commonScript.js:  
This is the js script that contains code responsible for the rendering of the gamescreens, bandits, bandit arms (i.e., the bar chart like vertical bars) and much more. Since the training and game phase has very similar visual structure with only minor differences, it is attached to both the training.html and game.html. This script maintains a tempData array to store all the data for each click made by the user. The data that is collected are the bandit number, gamescreen in which the bandit is clicked, the time elapsed since the page loaded until the click was registered, the lengths of both the bandit arms and the the gaussian noise added to each click and the total (sum of both the arm lengths and the gaussian noise). This is what is collected for each click in the training and game phase. Description of all the functions is given below.  
  
The function `renderScreens` basically takes in a number parameter. This grabs the html element with the class `game-container` and then assigns a formatted html string to the innerHTML. This function loops using the input parameter and adds as many gamescreens. This funtion also adds an id attribute ranging from to 1 to n (where n is the input parameter) so that they can be grabbed using this id in the rest of the script if needed.  
  
The function `renderBandits` takes in one input parameters which represents the number of bandits that need to be filled inside each game screen. This function grabs all the gamescreens that were created by `renderScreens` function. This function loops over each game screen and within each screen it loops for n times (where n is the input parameter) and fills each gamescreen with as many bandits (bandits are the small squircle looking boxes inside the gamescreen). While adding each bandit again the id attribute is assigned to each bandit starting from 1 and incrementing upto the total number of bandits in the entire game (i.e., number of gamescreens x number of bandits in each gamescreen). Bandit row is basically the row in which you only see 2 bandits. This is done to avoid inconsistent arrangement of the bandits on larger and smaller screens. This function creates a html hierarchy in which the gamescreen is at the top, inside which bandit rows are created. Inside the bandit rows, bandits are created. Inside each bandit, two divs are created. One is given the class bandit-score and the other is given the class bandit-content. The div with the class bandit-content is configured to have an onclick function that passes the `this` parameter to the `hubFunction` call. Inside each bandit we have 2 divs, each one has a class bandit-arms and bandit-arm-1 or bandit-arm-2. The one with the class bandit-arm-1 is the bar on the left and the one with the bandit-arm-2 is the bar on the right. 
  
The function `renderBanditArms` grabs all the gamescreens and loops over all of them and for each gamescreen it grabs all the html elements with class `bandit-arms` and then the function loops for each bandit arm and sets its height by making a call to the the `randomLengthGenerator`.  
  
The function `randomLengthGenerator` generates a random number and outputs a value in the range of 10 to 90 (exclusive) with step size of 10. This value is returned and is used by the renderBanditArms function to set the height of each bar in each bandit.  
  
The function `calculateReward` accepts one parameter which is the elementId which corresponds to the id attribute of the bandit. Then the height of both the arms are extracted for that bandit and then a call to the `gaussionNoiseGenerator` is made to get a noise value. Then the sum of the bandit arm heights and the noise is calculated. The arm heights and the gaussian noise are saved to the tempData array. Before returning from the function the total reward on the right top the webpage needs to be updated with this current reward. So a call to the `updateRewardCounter` is made and another to `displayReward` is made to display the calculated reward above the bandit that was clicked.  
  
The function `gaussionNoiseGenerator` takes in three parameters. They are the min and max values of the range in which the random number should be picked. Then a skew value which has a default value set to 1. The code for this is sourced from a stackoverflow discussion. The link to the discussion is put as a comment in the code. This essentially generates a random number in the specified min and max range while following a normal distribution. Skew of 1 means the normal distribution is not skewed towards left or right.  
  
The function `displayReward` takes in two parameters. First is the amount of reward and the second is the elementID (which corresponds to the bandit on which the reward should be displayed). The correct bandit is grabbed using the id and then the bandit score div within that bandit is grabbed and the reward value is set as the innerHTML. Then the score's visibility is turned on and turned off after 500ms (0.5s). This is the role of the `displayReward` function.  
  
The function `updateRewardCounter` accepts one parameter which is the amount of reward that was given to the user for clicking a certain bandit and this reward amount should be added to the total reward and should be displayed to the user. This function will check if the user has exhausted the allowed number of trials for that particular phase (training/game) and if not then the total reward is incremented by the input reward parameter amount and a boolean flag is updated if the user just finished all the allowed trials.  
  
The function `updateTrialCounter` checks if the user's running number of trails is less than the total number of the allowed trials and then increments the running trial count by one and displays the same on the webpage.  
  
The function `turnOnOverlay` function just grabs the html element with the id attribute as `overlay` and changes its display style to "block".  
  
The function `checkQuestionPoints` when invoked, checks if the currently finished number of trials matches with any of the points that a question is configured to be displayed and if it matches then the function `displayQuestionOverlay` is invoked.  
  
The function `displayQuestionOverlay` grabs the html element with the id `question-overlay` and changes its display style to block. Then it grabs the html element with class "question" and inserts the appropriate question into the displayed modal. Then the html element with the class `answer-options` is grabbed and html code that corresponds to a range slide that has a min of 0 and max of 10 the default value of 5 is inserted and the innerHTML. And the value of the slider is displayed on the modal for the user.  
  
The function `hideQuestionOverlay` grabs the slider value from the modal and saves it into a variable. If the key `userAnswers` is not present in the sessionStorage then it is created and the saved value is added or if already present then the currently saved value is added on the string with a semicolon as a separator. Then the html element with the id `question-overlay` is grabbed and its display style is set to none to turn off the modal.  
  
The function `togglePointerEvents` when invoked will disables the pointer events if they are enabled and enables them in if they are disabled on all the gamescreens. Disabling pointer events will not allow any clicks on the gamescreens.  
  
The function `toggleCursorStyle` when invoked will toggle the cursor style from normal (arrow) to the progress symbol (loading wheel or beach ball symbol) on the whole body element.  
  
The function `dataCollector` accepts one parameter which is the element (or bandit in our case). It then extracts the bandit number which was clicked, gamescreen number in which the clicked bandit is located, time elapsed since the page loaded, height of bandit arm 1 and height of the bandit arm 2. All of them are pushed into the tempData array.  

## trainingScript.js:  
This script is attached to the training.html after the commonScipt.js is attached. This script contains the code that is specific to the rendering and working of the training page in the app. The global variables declared at the beginning of the script like `gameScreensCount` represent the number of game screens the admin wants in the training phase and the variable `banditsCount` represent the number of bandits in each gamescreen. The variables `runningNumberOfTrails` and `totalNumberOfTrials` represent the currently used trials by the user and the maximum number of trials allowed in the training phase. Variables `totalRewardScored` and `isCompleteFlag` represent the total reward the user scored until now and the flag is a boolean representation of the completion status of the phase. The `trialClickDelayDuration` which is the number of milliseconds of delay that is implemented between each click on the bandit. The variable `startTime` (although initialized to 0) represent the number of milliseconds elapsed since the 1st January 1970 until the page has completed loading. The array `trainingData` will be filled with the data collected for each click as a subarray. The array `questionPoints` represent the trial counts at which a question from the `questionsList` is to be displayed. The number of elements in the `questionPoints` and `questionsList` should be equal. The description of the functions in this script is given below:  
  
The function that is executed on `window.onload` does the following things. First it checks if the user has reached the training page after going through the index page and the consent page by checking if the sessionStorage has userId, userAge, userGender and userHasAgreed keys with out null values in them. If any of these keys have null values then the user will redirected to the correct location in the app from where the data is missing. Then some of the html elements are grabbed using relevant class names and the variable values like the `runningNumberOfTrails`, `totalNumberOfTrials` and the `totalRewardScored` are displayed on the webpage using DOM Manipulation. Then a call to the `renderScreens` function is made to render the predefined number of game screens, another call to the `renderBandits` function is made to render the predefined number of bandits in each gamescreen. Another call to the `renderBanditArms` is a made to render bandit arms (the ones that look like thick vertical bars) in each bandit within all the gamescreens. For the training phase, we make all the gamescreens unclickable except for the second screen by making a call to the `makeScreensUnclickable` and passing the number of the screen that you want to exempt from being made unclickable. At this stage we will make a call to `checkQuestionPoints` if a question needs to be displayed at the very beginning of the experiment before even the user has used any trials. Next the startTime is set to the then `Date.now()` value. This will act as the starting time for the whole training phase.  
  
The function `makeScreensUnclickable` takes in one number input parameter and if nothing is passed in, the default value is -1. This function basically grabs all the gamescreen elements on the webpage and add a class `unclickable` to all the gamescreens except for the one that was passed in. If nothing is passed in or an invalid value (like an negative value or a value that is more than the number of screens), then all the gamescreens are made unclickable. When the class `unclickable` is added, the pointer events are disabled and the cursor sytling is turned into a not-allowed symbol to tell the user that click is not permitted on the disabled gamescreens.  
  
The function `turnOffOverlay` grabs the html element with the id `overlay` and changes the display style to none. After that, the trainingData array is assigned to the key "trainingData" in the sessionStorage after stringifying. After that the user is redirected to the game page.  
  
The function `hubFunction` accepts one parameter which is the element that is clicked. A call to the `dataCollector` function is made and the input parameter is passed on to it. The hubFunction is invoked when any bandit on the webpage is clicked. After the call to the dataCollector, calls to the `updateTrailCounter` and `checkQuestionPoints` are made. Then the id of the bandit that was clicked is extracted and a call to the `calculateReward` is made and the id of the clicked bandit is passed as an input parameter. This will calculate the reward and subsequently displays the reward and also updates the reward counter. The call to the dataCollector adds the data that was collected for each click and pushes it into the trainingData array as a subarrray. And then the tempData is set to an empty array so that the next call to the dataCollector can use the same array to collect the click data. After this, a check is made to turn on the overlay by calling the `turnOnOverlay` if the `runningNumberOfTrails` equals the `totalNumberOfTrials`. If there are some trials still remaining, then the function calls to `togglePointerEvents` and `toggleCursorStyle` will turn off the pointer events and also change the cursor style to "loading" type of cursor. Then a setTimeout is configured to run after `trialClickDelayDuration` and calls to the `renderBanditArms`, `togglePointerEvents` and `toggleCursorStyle` are made to re-render the bandit arms for each click (only done in the training phase), to turn on the pointer events and to revert the cursor style to normal. 
  

## game.html:  
Like the training.html page, this html page is also linked to two script files. One is the `commonScript.js` file and the other is the `gameScript.js`. The common script contains the code that is common to both the training page and the game page. The js code that is specific to each page is written in their own js files. This html template populates the html code into the content block of the base.html page. The content block in this html page first contains the html code for displaying a modal with an overlay. Then another similar style code block which is used to display question modals is present. Then the div that contains the trail counters and reward counters is present. After the above div, another last div is present which is populated by the commonScript.js and controlled by the trainingScript.js.  
  
## gameScript.js:  
This script is attached to the game.html after the commonScipt.js is attached. Since the structure and workings of both the training phase and game phase are mostly similar and only differ slightly in the way some gamescreens in the training phase are disabled and the way bandit arm heights are randomized for each click. But in game phase all the game screens are clickable and the bandit arm heights are not randomized for every click rather they are randomly sized once when the page loads for the first time. Except for these two differences the rest of the code structure and working in both the training phase and game phase are exactly the same. There might be some difference in the way the variables are named but their role in both the scripts is the same. Despite the similarity, the explanation for the entire code is present in this document for the sake of completeness and to not be misleading if any changes are made to any of the trainingScript.js or  the gameScript.js. Global variables that are declared at the beginning of the script are used to configure the behaviour and other settings in the game phase. Let's look at them one by one. The variables `gameScreenCount` and `banditsCount` represent the number of gamescreens in the webpage and also the number of bandits in each gamescreen just like in the trainingScript.js. The variables `runningNumberOfTrials` and `totalNumberOfTrials` represent the running count of trials used by the user and the total number of trials allowed for the user in the game phase. The variable `gameClickDelayDuration` is the number of milliseconds of delay that is implemented before allowing the user to register another click on the webpage. The empty array `gameData` that is declared at the top is used to collect the data that is related to each click in the form of subarrays. Just like in the trainingScript.js the arrays `questionPoints` and the `questionsList` represent the trial counts after which the user will be presented with a question from the questionsList.  
  
The function that is executed when the `window.onload` does the following things. First it checks if the user had come to this page after visiting the index page, consent page and training page by checking if the keys `userId`, `userAge`, `userGender`, `userHasAgreed` and the `trainingData` all have non null values or not. If any piece of the info is missing/null then the user is redirected to the correct page within the app to provide the necessary info or interact with the page in the specified manner to come to or stay in the game page. Once these checks are done, the html elements which displays the running count of trials, total number of trials and the total reward earned by the user until now are grabbed and the appropriate values are inserted. After that. calls to the functions `renderScreens`, `renderBandits` and the `renderBanditArms` are made to render the gamescreens, render bandits in each of those gamescreens and also to render the bandit arms in each of the bandits. Then a call to the `checkQuestionPoints` is made to check if a question should be displayed to the user at the very beginning of the game phase even before any trials were taken by the user. The the global variable `startTime` is initialized to the number of milliseconds elapsed since 1st January 1970 (also called Epoch). This is used as a reference to calculate the time taken by the user for each click.  
  
The function `turnOffOverlay` grabs the html element with the id of `overlay` and sets its display style property to none essentially turning off the overlay. Then the gameData which was grown over the time with each click by adding subarrays which represent the data collected for each click made by the user is stringified and then set as the value to the key `gameData` in the sessionStorage. After that the user is redirected to the thankyou page (i.e, thankyou route on the controller is accessed).  
  
The function `hubFunction` in the gameScript.js is very similar to the hubFunction in the trainingScript.js with only some minor differences. Firstly this function calls the `dataCollector` function by passing the element (i.e., the bandit that is clicked) to collate all the data into the tempData array. This hubFunction is invoked for each click registered on the bandits. After the call to the `dataCollector`, calls are made to the `updateTrialCounter` which increments the `runningNumberOfTrials` variable by 1 after checking if the `runningNumberOfTrials` is less than the `totalNumberOfTrials`. After that function call is complete, another call to the `checkQuestionPoints` is made to check if a question should be presented to the user at the current trial count. After that the id attribute value of the bandit that was clicked is extracted and is sent to the `calculateReward` which calculates the reward that bandit has generated and the total reward counter is updated. The generated reward is also displayed right above the bandit for the user to see. Then the `tempData` that was filled with relevant data regarding the latest click is pushed into the `gameData` array as a subarray and the `tempData` is set to an empty array so the next call to the `dataCollector` function can use the empty `tempData` to fill in the information. At this point the `runningNumberOfTrials` is checked to see if it is equal to the `totalNumberOfTrials` and if so then the overlay is turned on by making a call to the `turnOnOverlay` function. The close button on the overlay will invoke the `turnOffOverlay` function which will redirect the user to the thankyou page as discussed earlier so the user cannot register any more clicks. If there are still any trials left, just like in the trainingScript.js calls are made to the `togglePointerEvents` and `toggleCursorStyle` function to disable the pointer events (so that another click cannot be registered until they are turned back on) and to change the cursor into a "loading" or "in progress" kind of cursor to indicate the user that another click cannot be registered for now. Then a `setTimeout` is used to make function calls to the `togglePointerEvents` and `toggleCursorStyle` after the predefined `gameClickDelayDuration` amount of time. Here as you can notice a function call to the `renderBanditArms` is not made within the setTimeout because we dont wish to randomize the bandit arm heights for each click unlike the trainingScript.js.  
  
  
## thankyou.html:  
This html page shows the user a thankyou message and the unique submission code that was generated for them to submit back in the MTurk portal for claiming their participation award. As other html pages this html document also extends the base.html and links to its corresponding css and js files. This html page also shows a "Go to Homepage' button that takes the user to the index page. 

## thankyouScript.js:  
This js file contains a function that runs on successful window load. This function checks if the user has reached this page after going through the right sequence of pages (index -> consent -> training -> game). The function checks this by checking for variables key value pairs present in the sessionStorage and if something is missing then the user will be redirected to the page where the data is missing. And if the user has come to this page through the correct sequence, then the uploadToDatabase function is called. This function will collate all the data from the sessionStorage into one array and then stringifies the data for tranmission to server using an AJAX POST request to the thankyou route on the controller file. Check the thankyou function description in the app.py section to understand its role. Once the AJAX request is made, the submission code is sent back to this js file which will be inserted into thankyou.html page using DOM manipulation. If some error occurs in the process of uploading to the database then the user will be redirected to the error.html page. Else the sessionStorage is cleared so that new user can take the experiment without any issues after an user has taken the experiment in the same browser.  
  
  
## error.html:  
This html page is not associated with any js files but has a style sheet attached to it. This page is shown when any error occurs in the app. This is created to show a graceful looking screen when an error occurs rather than displaying the default error screen. This page also has a button that takes the user to the index page.  
  
  
## duplicate.html:  
This html page is also not associated with any js file but has a style sheet attached to it. If a user tries to take the experiment for second time, then the controller will actually detect the presence of this user id and will redirect them to the duplicate.html page where their submission code is displayed for the user's reference.  
  
  
## admin_login.html:  
This html file contains the login form to the admin dashboard. Upon submission of correct credentials a POST request is made to the admin_login route on the controller and if the credentials are correct the admin will be logged into their dashboard. This html file is also not associated with any js file but has a stylesheet attached to it.  
  
  
## admin_dashboard.html:  
This html file displays the admin dashboard after successful login. Here the admin can get a quick glimpse of the total number of submissions until now and the number of male/female/other participants who have completed the experiment. This html file has a stylesheet and a js script associated with it. On this dashboard, the admin can see the userid, age, gender and the submission code that was assigned to each userid. If no one has taken the experiment yet, then a corresponding messgae is shown to the admin instead of just leaving the table empty as it might sometimes give the impression that the data is about to load.  
  
## adminDashboardScript.js:  
Admin can click the Download button on the dashboard and doing so will invoke the `exportToCSV` function in this js script file which will make a fresh call to the `admin_data_download` route on the controller to fetch the then latest data from the database and to write the received data into a CSV file. Then a file explorer dialog is opened for the user to modify the file name and save the file. By default the date on which the file is downloaded is appended to the file name. This function is similar to the `exportToCSV` function in the FIPS Data Entry System.
